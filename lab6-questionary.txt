1) we Made a zero-copy transmit implementation. The transmit descriptor cyclic queue is sizeof 16 when each transmit descriptor is as mentioned in the lab. we implemented the zero copy transmit so the address in the descriptor is changed to a given user pointer which is the buffer we want to send. when the transmit is full, the transmit function return -1, BUT the syscall which call the transmit sends to sleep. The reason we have decided to put the env to sleep in the syscall is because it is implemented in the kernel space and the sleep as we implemented it is will wake up in the user space so it would be useless. In addition we added to the env_desc a field named env_e1000_trans, which is some kind of a channel for the env to sleep on, when we will get an interrupt the we got free spot for transmitting the interrupt handler will wake up all the processes.

2) for receiving we also made a zero-copy receive. The receive data structure is the recieveing descriptors, in addition we have an array of buffers, which we set each buffer to point to USER SPACE. We named this addresses ZERO_COPY_BASE. every time a packet arrives we direct the user to point to the correct address in ZERO_COPY_BASE so the user can use it. The size of the queue is 128 descriptors. When the queue is full, as in transmit, we return -1 so the sys call can put the env to sleep with a flag named env_e1000_rec and when an interrupt of a package will arrive the interrupt handler will wake all the processes which are waiting for a package up. 

3)the web page said for header - “This file came from JOS.” And body “Cheesy web page!”

4)this was the longest lab we did. It took us only the lab before the challenges 20 hours, and the challenges (all three!)took 10 hours  